1.Create main layout
2.定义class Basic 和 Education
3.定义工具类 DateUtils
4.动态列表，利用getLayoutInflater.inflate
5.getLayoutInflater().inflate() 相当于LayoutInflater.from(this).infate();
6.。。。写一个抽象类EditBase，里面完成menu功能，调用自己的抽象方法。
7.以上已经完成添加修改，下面开始完成修改头像
8.修改Basic类，添加变量Uri:  新知识点： classloader
我们看到了系统的3个类加载器，但我们可能不知道具体哪个先行呢？ 
我可以先告诉你答案 
1. Bootstrap CLassloder 
2. Extention ClassLoader 
3. AppClassLoader
用序列描述一下： 
1. 一个AppClassLoader查找资源时，先看看缓存是否有，缓存有从缓存中获取，否则委托给父加载器。 
2. 递归，重复第1部的操作。 
3. 如果ExtClassLoader也没有加载过，则由Bootstrap ClassLoader出面，它首先查找缓存，如果没有找到的话，就去找自己的规定的路径下，也就是sun.mic.boot.class下面的路径。找到就返回，没有找到，让子加载器自己去找。 
4. Bootstrap ClassLoader如果没有查找成功，则ExtClassLoader自己在java.ext.dirs路径中去查找，查找成功就返回，查找不成功，再向下让子加载器找。 
5. ExtClassLoader查找不成功，AppClassLoader就自己查找，在java.class.path路径下查找。找到就返回。如果没有找到就让子类找，如果没有子类会怎么样？抛出各种异常。

上面的序列，详细说明了双亲委托的加载流程。我们可以发现委托是从下向上，然后具体查找过程却是自上至下。
自定义ClassLoader

不知道大家有没有发现，不管是Bootstrap ClassLoader还是ExtClassLoader等，这些类加载器都只是加载指定的目录下的jar包或者资源。如果在某种情况下，我们需要动态加载一些东西呢？比如从D盘某个文件夹加载一个class文件，或者从网络上下载class主内容然后再进行加载，这样可以吗？

如果要这样做的话，需要我们自定义一个classloader。
1。编写一个类继承自ClassLoader抽象类。
2.复写它的findClass()方法。
3.在findClass()方法中调用defineClass()。
